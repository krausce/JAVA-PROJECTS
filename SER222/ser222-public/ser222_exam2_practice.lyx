#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\branch blank
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch soln
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 2.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center

\size huge
SER 222 
\series bold
Practice
\series default
 Exam 2
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\size huge
(SOLN)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
Updated 5/14/2019
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
Last Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{6cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{5.94cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Last 4 digits of ASU ID: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{4.05cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\align center
Exam Instructions
\end_layout

\begin_layout Standard
The exam is open textbook (Algorithms 4e by Sedgewick and Wayne), as well
 as open note.
 
\bar under
No electronic items are allowed.
 Write legibly.

\bar default
 Please use a pen (instead of a pencil) if you have one.
 There are 110 points available and the exam must be completed in 37.5 minutes.
 This exam has two types of questions:
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short answer questions:
\series default
 There are 80 points of short answer questions.
 A typical answer is one or two sentences.
 Each short answer question is worth 10 or 5 points.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Write-in questions:
\series default
 The programming questions are given near the end of the paper.
 They must be answered on the question paper.
 There are 0 points of write-in programming questions.
\end_layout

\begin_layout Standard
\begin_inset VSpace 10cm
\end_inset


\end_layout

\begin_layout Standard
\align right
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Topic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Earned
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Possible
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Elementary Sorts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Mergesort
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Priority Queues
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Symbol Tables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
80
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Elementary Sorts
\end_layout

\begin_layout Enumerate
What are the Big-Oh and Tilde orders of the following code fragment? The
 fragment is parametrized on the variable 
\begin_inset Formula $n$
\end_inset

.
 Assume that you are measuring the number of swap calls.
 [10 points] 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
From FC15 final.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public static void sort(Comparable[] a) {
\end_layout

\begin_layout Plain Layout

    int n = a.length;
\end_layout

\begin_layout Plain Layout

    for (int j = 0; j < n-1; j++) {
\end_layout

\begin_layout Plain Layout

        int z = j;
\end_layout

\begin_layout Plain Layout

        for (int i = j+1; i < n; i++) {
\end_layout

\begin_layout Plain Layout

            if (a[i] < a[z]) {
\end_layout

\begin_layout Plain Layout

                z = i;
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if(z != j) {
\end_layout

\begin_layout Plain Layout

          swap(a[j], a[z]); //count these
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
What is the Big-Oh order of the above code fragment? If it does not exist,
 then explain.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans: [AcuÃ±a]
\end_layout

\begin_layout Standard
It is O(n) since it is inside one loop with linear incrementor.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
What is the Tilde order of the above code fragment? If it does not exist,
 then explain.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans: [AcuÃ±a]
\end_layout

\begin_layout Standard
It does not exist, swap only runs if z != j and we can't know how often
 that occurs without knowing the data.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
When dealing with systems having low RAM capacity, or analyzing large datasets,
 space is at a premium.
 In these cases, algorithms must be designed to reduce their memory foot
 print.
 From the sorting algorithm implementations seen in class, which would be
 the best choice? [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
(Any of the in-place sorting algorithms would be fine: selection sort, insertion
 sort, or shell sort.)
\end_layout

\begin_layout Standard
Selection sort.
 We don't want to use mergesort since it requires creating an auxiliary
 array which doubles the space used.
 Mergesort is also bad because it requires stack memory for recursive calls.
\end_layout

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Mergesort
\end_layout

\end_deeper
\begin_layout Enumerate
[AcuÃ±a] Consider the following array: 23, 7, 35, 3, 4, 2, 13, 1.
 Show a trace of execution for top-down mergesort.
 Illustrate how the array is broken down, and then merged into an ordered
 state.
 [10 points]
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 10cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
[23, 7, 35, 3, 4, 2, 13, 1]
\end_layout

\begin_layout Standard
[[23, 7, 35, 3], [4, 2, 13, 1]]
\end_layout

\begin_layout Standard
[[[23, 7], [35, 3]], [[4, 2], [13, 1]]]
\end_layout

\begin_layout Standard
[[[[23], [7]], [[35], [3]]], [[[4], [2]], [[13], [1]]]]
\end_layout

\begin_layout Standard
[[[7, 23], [3, 35]], [[2, 4], [1, 13]]]
\end_layout

\begin_layout Standard
[[3, 7, 23, 35], [1, 2, 4, 13]]
\end_layout

\begin_layout Standard
[1, 2, 3, 4, 7, 13, 23, 35]
\end_layout

\begin_layout Standard
\begin_inset VSpace 6cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
In the lower bound proof for sorting, why must there be at least N! leaves
 on the decision tree? [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans: [AcuÃ±a]
\end_layout

\begin_layout Standard
A sorting algorithm must be able to sort (solve) any input.
 Given that the input is an array of size N, then there are N! permutations
 of it.
 Since each result is represented as a leaf, we need N! leaves to have enough
 solutions available for the possible inputs.
 This is the equivalent of saying that the tree contains a path which leads
 to the solution of each possible input.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Priority Queues 
\end_layout

\end_deeper
\begin_layout Enumerate
What is the difference between a (max) heap and a priority queue? [10 points]
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
A heap is a data structure and a priority queue is an ADT.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
One of the main operations for a PQ is to move an element lower in a heap,
 so that it will be in the proper order.
 It is implemented by the sink() method.
 According to lecture, this particular implementation takes 
\begin_inset Formula $O(log(n))$
\end_inset

 number of exchanges to put the element in its proper place.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    private void sink(int k) {
\end_layout

\begin_layout Plain Layout

        while (2*k <= N) {
\end_layout

\begin_layout Plain Layout

            int j = 2*k;
\end_layout

\begin_layout Plain Layout

            if (j < N && less(j, j+1))
\end_layout

\begin_layout Plain Layout

              j++;
\end_layout

\begin_layout Plain Layout

            if (!less(k, j))
\end_layout

\begin_layout Plain Layout

              break;
\end_layout

\begin_layout Plain Layout

            exch(k, j);
\end_layout

\begin_layout Plain Layout

            k = j;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Support this claim by explaining why this method is 
\begin_inset Formula $O(log(n))$
\end_inset

: [10 points]
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
The height of the tree will be 
\emph on

\begin_inset Formula $log_{2}(n)$
\end_inset


\emph default
, where 
\emph on
n
\emph default
 is the number of nodes, so since each loop iteration moves down one level,
 it can run a maximum of 
\begin_inset Formula $log_{2}(n)$
\end_inset

 times.
\end_layout

\begin_layout Standard
\begin_inset VSpace 1cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Symbol Tables
\end_layout

\end_deeper
\begin_layout Enumerate
Trace an initially empty symbol table (called ST) through the following
 operations:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SymbolTable<> ST = new BinarySearchTree<String, Integer>();
\end_layout

\begin_layout Plain Layout

ST.put("SER100", 150);
\end_layout

\begin_layout Plain Layout

ST.put("SER200", 150);
\end_layout

\begin_layout Plain Layout

ST.put("SER250", 100);
\end_layout

\begin_layout Plain Layout

ST.put("SER316", 100);
\end_layout

\begin_layout Plain Layout

System.out.println(ST.get("SER200"));
\end_layout

\begin_layout Plain Layout

ST.put("SER200", 250);
\end_layout

\begin_layout Plain Layout

ST.put("SER316", 75);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Give the contents of the symbol table after the code has been executed.
 Use the format ABC### : ### (e.g., 
\begin_inset Quotes eld
\end_inset

SER100 : 100
\begin_inset Quotes erd
\end_inset

) to give your answer.
 Use separate lines for each key/value pair.
 [10 points]
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SER100 : 150
\end_layout

\begin_layout Plain Layout

SER200 : 250
\end_layout

\begin_layout Plain Layout

SER250 : 100
\end_layout

\begin_layout Plain Layout

SER316 : 75
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Consider the task of implementing a SymbolTable vs an OrderedSymbolTable.
 For the purposes of get and put, which you be more likely to create an
 efficient implementation for? Explain.
 (Hint: no knowledge of BSTs or hashtables is needed.) [10 points]
\begin_inset Note Note
status open

\begin_layout Plain Layout
Created for SA18.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
OrderedSymbolTable offers more potential for optimization since itmeans
 you have some structure (i.e., all elements are Comparable) on the data which
 you can exploit.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Programming: ???
\end_layout

\begin_layout Standard

\emph on
There will be at least one programming question on the actual exam.
\end_layout

\end_deeper
\end_body
\end_document
