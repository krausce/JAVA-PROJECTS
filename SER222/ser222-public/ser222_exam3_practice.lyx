#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\branch blank
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch soln
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 2.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center

\size huge
SER 222 
\series bold
Practice
\series default
 Exam 3
\end_layout

\begin_layout Standard
\align center
Updated 5/14/2019
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
Last Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{6cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{5.94cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Last 4 digits of ASU ID: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{4.05cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\align center
Exam Instructions
\end_layout

\begin_layout Standard
The exam is open textbook (Algorithms 4e by Sedgewick and Wayne), as well
 as open note.
 
\bar under
No electronic items are allowed.
 Write legibly.

\bar default
 Please use a pen (instead of a pencil) if you have one.
 There are 90 points available and the exam must be completed in 37.5 minutes.
 This exam has two types of questions:
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short answer questions:
\series default
 There are 90 points of short answer questions.
 A typical answer is one or two sentences.
 Each short answer question is worth 5 or 10 points.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Write-in questions:
\series default
 The programming questions are given near the end of the paper.
 They must be answered on the question paper.
 There are 20 points of longer write-in questions.
\end_layout

\begin_layout Standard
\begin_inset VSpace 6cm
\end_inset


\end_layout

\begin_layout Standard
\align right
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Topic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Earned
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Possible
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Binary Search Trees
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Hashtables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Undirected Graphs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Directed Graphs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scen: Hashtables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scen: Undirected Graphs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scen: Directed Graphs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Binary Search Trees
\end_layout

\begin_layout Enumerate
Trace a (non-balancing) BST through the following operations:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename practice_exams/ser222_17f_bst.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

//assume that the "tree" variable below has already been constructed,
\end_layout

\begin_layout Plain Layout

//per the tree shown above.
\end_layout

\begin_layout Plain Layout

tree.add(new Integer(3));
\end_layout

\begin_layout Plain Layout

tree.add(new Integer(7));
\end_layout

\begin_layout Plain Layout

tree.add(new Integer(2));
\end_layout

\begin_layout Plain Layout

tree.remove(new Integer(6));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Draw the structure of the BST after each call.
 Images must be cumulative.
 [10 points]
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 14cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename practice_exams/ser222_exam3_practice_q1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
When adding and removing nodes from a heap, the tree structure will always
 remain balanced.
 Why is it the case that when these operations are performed over a BST,
 there is a chance that the tree will become unbalanced? [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
In a BST, there is exactly one place a node may be added.
 This position might be selected such that a stilted tree is formed (ex:
 consider adding elements in sequence).
 In a heap, a node may end up in different places since although it is added
 to the 
\begin_inset Quotes eld
\end_inset

last
\begin_inset Quotes erd
\end_inset

 position, swim is used to move it upward to a valid position.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Hashtables
\end_layout

\end_deeper
\begin_layout Enumerate
Is the hashCode() implementation in the following Point2D class valid? That
 is, would a hashtable be able to properly store keys with this hashCode?
 Explain.
 [10 points] 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
From FC17 final.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Point2D {
\end_layout

\begin_layout Plain Layout

    public int x, y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Point2D(int x, int y) { this.x = x; this.y = y;}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public int hashCode() {
\end_layout

\begin_layout Plain Layout

        return x % Integer.MAX_VALUE;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
No.
 It does not encode the identity of the y member variable, and the modulus
 means that even objects with different x values may produce the same hash.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Imagine that you have a linear probe hashtable, with M=11.
 Draw the final hashtable after adding these keys: 34, 13, 10, 3, 0, 15,
 14.
 Use the hash function 
\begin_inset Formula $hash(k,i)=(k\;mod\;11+i)\;mod\;11$
\end_inset

, where 
\begin_inset Formula $i$
\end_inset

 is number of times the algorithm has tried to insert the key.
 Your drawing should include the main size M array.
 [20 points] 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
From FC17 final.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 14cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="11">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Undirected Graphs
\end_layout

\end_deeper
\begin_layout Enumerate
Would the DFS algorithm run faster if it was implemented with an adjacency
 matrix or an adjacency list? Justify.
 [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
It would be faster with an adjacency list.
 It only accesses the graph via the adj() method, which in an adjacency
 matrix is ~V, while in an adjacency list is ~degree(V).
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
If you are asked to run a DFS or BFS by hand, and given a picture of the
 graph, the code for the algorithm, and a start node, why is there a chance
 you and a classmate who correctly execute the algorithm will produce different
 paths? [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
The order in which you explore outward from a particular node is dependent
 on the order returned by the adj() method.
 Without a rule, or an adjacency list, the order of the neighbors you each
 choose to explore may be different.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Directed Graphs
\end_layout

\end_deeper
\begin_layout Enumerate
When using DFS to check for a cycle in a directed graph, can we simply check
 for the algorithm visiting a marked node? Explain yes or no.
 [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
No.
 It may be the case that there are multiple incoming edges to a node but
 no outgoing edges, in which it would become marked but since it's not possible
 to leave the node, it's not part of a cycle.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
In the DFS based topological sort, what would happen if nodes were pushed
 on the stack before their children were explored, rather than after? Would
 the algorithm still work? Explain.
 [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
No.
 We lose the logic which makes sure that a node is only listed after its
 children have been listed, which, in reverse, gives us the topological
 sort solution.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Programming: Binary Search Trees
\end_layout

\end_deeper
\begin_layout Enumerate
One of the data structures we studied is Binary Search Trees (BST).
 A simple implementation of a node for a binary tree is shown below.
 For this question, you are to implement a method called isBST that takes
 first node in a binary tree (its root) and returns true if it is the root
 of a BST, and false otherwise.
 Be careful with your syntax.
 [30 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

    private class Node {
\end_layout

\begin_layout Plain Layout

        public final Key key;
\end_layout

\begin_layout Plain Layout

        public Value val;
\end_layout

\begin_layout Plain Layout

        public Node left, right;
\end_layout

\begin_layout Plain Layout

        public int N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        public Node(Key key, Value val, int N) {
\end_layout

\begin_layout Plain Layout

            this.key = key; this.val = val; this.N = N;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    private static boolean isBST(Node root) {
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 12cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

private class Node {
\end_layout

\begin_layout Plain Layout

  public final Key key;
\end_layout

\begin_layout Plain Layout

  public Value val;
\end_layout

\begin_layout Plain Layout

  public Node left, right;
\end_layout

\begin_layout Plain Layout

  public int N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public Node(Key key, Value val, int N) {
\end_layout

\begin_layout Plain Layout

      this.key = key; this.val = val; this.N = N;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public static boolean isBST(Node root, ) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public static boolean isBST(Node root) {
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if(root == null)
\end_layout

\begin_layout Plain Layout

    return true;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if(root.left != null && root.left.key >= root.key)
\end_layout

\begin_layout Plain Layout

    return false;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if(root.right != null && root.right.key <= root.key)
\end_layout

\begin_layout Plain Layout

    return false;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return isBST(root.left) && isBST(root.right);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

private class Node {
\end_layout

\begin_layout Plain Layout

    public final Key key;
\end_layout

\begin_layout Plain Layout

    public Value val;
\end_layout

\begin_layout Plain Layout

    public Node left, right;
\end_layout

\begin_layout Plain Layout

    public int N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Node(Key key, Value val, int N) {
\end_layout

\begin_layout Plain Layout

        this.key = key; this.val = val; this.N = N;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//UGTA Cole: There are many ways to solve this problem.
\end_layout

\begin_layout Plain Layout

public boolean isBST(Node root) {
\end_layout

\begin_layout Plain Layout

    List<Integer> nodeVals = new ArrayList<>();
\end_layout

\begin_layout Plain Layout

    inOrder(root, nodeVals);
\end_layout

\begin_layout Plain Layout

    return isSorted(nodeVals);    
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

private void inOrder(Node node, List<Integer> vals){
\end_layout

\begin_layout Plain Layout

    if(node == null) return;
\end_layout

\begin_layout Plain Layout

    inOrder(node.left, vals);
\end_layout

\begin_layout Plain Layout

    vals.add(node.val);
\end_layout

\begin_layout Plain Layout

    inOrder(node.right, vals);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

private boolean isSorted(List<Integer> vals){
\end_layout

\begin_layout Plain Layout

    long lastVal = Long.MIN_VALUE;
\end_layout

\begin_layout Plain Layout

    for(Integer x : vals){
\end_layout

\begin_layout Plain Layout

        if(x <= lastVal) return false;
\end_layout

\begin_layout Plain Layout

        lastVal = x;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return true;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Programming: Undirected Graphs
\end_layout

\end_deeper
\begin_layout Enumerate
Run the 
\series bold
BFS
\series default
 algorithm on this graph to compute the shortest paths between 0 and every
 other node.
 For reference, the BFS algorithm is shown on the next page.
 Use the adjacency list above for the order of the nodes explored and follow
 the trace format shown before.
 Your answer must include the values of 
\emph on
v
\emph default
, 
\emph on
queue
\emph default
, and 
\emph on
edgeTo
\emph default
, as they update.
 [20 points]
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Description
\begin_inset Graphics
	filename practice_exams/ser222_exercise11_graph1.png
	scale 50

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3, 1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0, 4, 3, 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1, 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1, 0, 4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1, 3, 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2, 4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Sample graph.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard

\series bold
Before loop:
\end_layout

\begin_layout Standard
marked[
\begin_inset Formula $\;\;\;$
\end_inset

]=
\end_layout

\begin_layout Standard
queue={
\begin_inset Formula $\;\;\;$
\end_inset

}
\end_layout

\begin_layout Standard

\series bold
Loop 1:
\end_layout

\begin_layout Standard
v=
\end_layout

\begin_layout Standard
edgeTo[
\begin_inset Formula $\;\;\;$
\end_inset

]=
\end_layout

\begin_layout Standard
edgeTo[
\begin_inset Formula $\;\;\;$
\end_inset

]=
\end_layout

\begin_layout Standard
queue = {
\begin_inset Formula $\;\;\;$
\end_inset


\begin_inset Formula $\;\;\;$
\end_inset


\begin_inset Formula $\;\;\;$
\end_inset

}
\end_layout

\begin_layout Standard
\begin_inset VSpace 6cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Before loop:
\end_layout

\begin_layout Standard
marked[0]=T
\end_layout

\begin_layout Standard
queue={0} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 1:
\end_layout

\begin_layout Standard
v=0
\end_layout

\begin_layout Standard
edgeTo[3]=0
\end_layout

\begin_layout Standard
edgeTo[1]=0
\end_layout

\begin_layout Standard
queue = {1, 3} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 2:
\end_layout

\begin_layout Standard
v = 3
\end_layout

\begin_layout Standard
edgeTo[4] = 4
\end_layout

\begin_layout Standard
queue = {4, 1} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 3:
\end_layout

\begin_layout Standard
v = 1
\end_layout

\begin_layout Standard
edgeTo[2]=1
\end_layout

\begin_layout Standard
queue={2, 4} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 4:
\end_layout

\begin_layout Standard
v = 4
\end_layout

\begin_layout Standard
edgeTo[5]=4
\end_layout

\begin_layout Standard
queue={5, 2} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 5:
\end_layout

\begin_layout Standard
v = 2
\end_layout

\begin_layout Standard
queue={5} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 6:
\end_layout

\begin_layout Standard
v = 5
\end_layout

\begin_layout Standard
queue = {}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public class BreadthFirstPaths {
\end_layout

\begin_layout Plain Layout

    private boolean[] marked;
\end_layout

\begin_layout Plain Layout

    private int[] edgeTo;
\end_layout

\begin_layout Plain Layout

    private final int s;
\end_layout

\begin_layout Plain Layout

    public BreadthFirstPaths(Graph G, int s) {
\end_layout

\begin_layout Plain Layout

        marked = new boolean[G.V()];
\end_layout

\begin_layout Plain Layout

        edgeTo = new int[G.V()];
\end_layout

\begin_layout Plain Layout

        this.s = s;
\end_layout

\begin_layout Plain Layout

        bfs(G, s);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    private void bfs(Graph G, int s) {
\end_layout

\begin_layout Plain Layout

        Queue<Integer> queue = new LinkedList<>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        marked[s] = true;
\end_layout

\begin_layout Plain Layout

        queue.add(s);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        while (!queue.isEmpty()) {
\end_layout

\begin_layout Plain Layout

            int v = queue.remove();
\end_layout

\begin_layout Plain Layout

            for (int w : G.adj(v))
\end_layout

\begin_layout Plain Layout

                if (!marked[w]) {
\end_layout

\begin_layout Plain Layout

                    edgeTo[w] = v;
\end_layout

\begin_layout Plain Layout

                    marked[w] = true;
\end_layout

\begin_layout Plain Layout

                    queue.add(w);
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public boolean hasPathTo(int v) {
\end_layout

\begin_layout Plain Layout

        return marked[v];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Iterable<Integer> pathTo(int v) {
\end_layout

\begin_layout Plain Layout

        if(!hasPathTo(v))
\end_layout

\begin_layout Plain Layout

            return null;
\end_layout

\begin_layout Plain Layout

        Stack<Integer> path = new Stack<>();
\end_layout

\begin_layout Plain Layout

        for(int x = v; x != s; x = edgeTo[x])
\end_layout

\begin_layout Plain Layout

            path.push(x);
\end_layout

\begin_layout Plain Layout

        path.push(s);
\end_layout

\begin_layout Plain Layout

        return path;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
BFS for pathing.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
